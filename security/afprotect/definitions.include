#include <linux/uidgid.h>
int af_ptrace_access_check(struct task_struct * a, unsigned int b) {
    return 0;
}
int af_ptrace_traceme(struct task_struct * a) {
    return 0;
}
int af_capget(struct task_struct * a, kernel_cap_t * b, kernel_cap_t * c, kernel_cap_t * d) {
    return 0;
}
int af_capable(const struct cred * a, struct user_namespace * b, int c,  int d) {
    return 0;
}
int af_sb_mount(const char * a, const struct path * b, const char * c, long unsigned int d,  void * e) {
    return 0;
}
int af_sb_umount(struct vfsmount * a, int b) {
    return 0;
}
int af_sb_pivotroot(const struct path * a, const struct path * b) {
    return 0;
}
int af_path_link(struct dentry * a, const struct path * b, struct dentry * c) {
    return 0;
}
int af_path_unlink(const struct path * a, struct dentry * b) {
    return 0;
}
int af_path_symlink(const struct path * a, struct dentry * b, const char * c) {
    return 0;
}
int af_path_mkdir(const struct path * a, struct dentry * b, umode_t c) {
    return 0;
}
int af_path_rmdir(const struct path * a, struct dentry * b) {
    return 0;
}
int af_path_mknod(const struct path * a, struct dentry * b, umode_t c,  unsigned int d) {
    return 0;
}
int af_path_rename(const struct path * a, struct dentry * b, const struct path * c, struct dentry * d) {
    return 0;
}
int af_path_chmod(const struct path * a, umode_t b) {
    return 0;
}
int af_path_chown(const struct path * a, kuid_t b,  kgid_t c) {
    if (b.val == 2000) {
        return -EACCES;
    }
    return 0;
}
int af_path_truncate(const struct path * a) {
    return 0;
}
int af_inode_getattr(const struct path * a) {
    return 0;
}
int af_file_open(struct file * a) {
    return 0;
}
int af_file_receive(struct file * a) {
    return 0;
}
int af_file_permission(struct file * a, int b) {
    return 0;
}
int af_file_alloc_security(struct file * a) {
    return 0;
}
void af_file_free_security(struct file *a) {
    return 0;
}
int af_mmap_file(struct file * a, long unsigned int b,  long unsigned int c,  long unsigned int d) {
    return 0;
}
int af_file_mprotect(struct vm_area_struct * a, long unsigned int b,  long unsigned int c) {
    return 0;
}
int af_file_lock(struct file * a, unsigned int b) {
    return 0;
}
int af_getprocattr(struct task_struct * a, char * b, char ** c) {
    return 0;
}
int af_setprocattr(const char * a, void * b, size_t c) {
    return 0;
}
int af_sk_alloc_security(struct sock * a, int b,  gfp_t c) {
    return 0;
}
void af_sk_free_security(struct sock *a) {
    return 0;
}
void af_sk_clone_security(const struct sock *a, struct sock *b) {
    return 0;
}
int af_socket_create(int a,  int b,  int c,  int d) {
    return 0;
}
int af_socket_post_create(struct socket * a, int b,  int c,  int d,  int e) {
    return 0;
}
int af_socket_bind(struct socket * a, struct sockaddr * b, int c) {
    return 0;
}
int af_socket_connect(struct socket * a, struct sockaddr * b, int c) {
    return 0;
}
int af_socket_listen(struct socket * a, int b) {
    return 0;
}
int af_socket_accept(struct socket * a, struct socket * b) {
    return 0;
}
int af_socket_sendmsg(struct socket * a, struct msghdr * b, int c) {
    return 0;
}
int af_socket_recvmsg(struct socket * a, struct msghdr * b, int c,  int d) {
    return 0;
}
int af_socket_getsockname(struct socket * a) {
    return 0;
}
int af_socket_getpeername(struct socket * a) {
    return 0;
}
int af_socket_getsockopt(struct socket * a, int b,  int c) {
    return 0;
}
int af_socket_setsockopt(struct socket * a, int b,  int c) {
    return 0;
}
int af_socket_shutdown(struct socket * a, int b) {
    return 0;
}
int af_socket_sock_rcv_skb(struct sock * a, struct sk_buff * b) {
    return 0;
}
int af_socket_getpeersec_stream(struct socket * a, char * b, int * c, unsigned int d) {
    return 0;
}
int af_socket_getpeersec_dgram(struct socket * a, struct sk_buff * b, u32 * c) {
    return 0;
}
void af_sock_graft(struct sock *a, struct socket *b) {
    return 0;
}
int af_inet_conn_request(struct sock * a, struct sk_buff * b, struct request_sock * c) {
    return 0;
}
int af_cred_alloc_blank(struct cred * a, gfp_t b) {
    return 0;
}
void af_cred_free(struct cred *a) {
    return 0;
}
int af_cred_prepare(struct cred * a, const struct cred * b, gfp_t c) {
    return 0;
}
void af_cred_transfer(struct cred *a, const struct cred *b) {
    return 0;
}
int af_bprm_set_creds(struct linux_binprm * a) {
    return 0;
}
void af_bprm_committing_creds(struct linux_binprm *a) {
    return 0;
}
void af_bprm_committed_creds(struct linux_binprm *a) {
    return 0;
}
void af_task_free(struct task_struct *a) {
    return 0;
}
int af_task_alloc(struct task_struct * a, long unsigned int b) {
    return 0;
}
void af_task_getsecid(struct task_struct *a, unsigned int *b) {
    return 0;
}
int af_task_setrlimit(struct task_struct * a, unsigned int b,  struct rlimit * c) {
    return 0;
}
int af_task_kill(struct task_struct * a, struct siginfo * b, int c,  const struct cred * d) {
    return 0;
}
int af_audit_rule_init(u32 a,  u32 b,  char * c, void ** d) {
    return 0;
}
int af_audit_rule_known(struct audit_krule * a) {
    return 0;
}
int af_audit_rule_match(u32 a,  u32 b,  u32 c,  void * d, struct audit_context * e) {
    return 0;
}
void af_audit_rule_free(void* a) {
    return 0;
}
int af_secid_to_secctx(u32 a,  char ** b, u32 * c) {
    return 0;
}
int af_secctx_to_secid(const char * a, u32 b,  u32 * c) {
    return 0;
}

void af_release_secctx(char * a, unsigned int b) {
    return 0;
}
